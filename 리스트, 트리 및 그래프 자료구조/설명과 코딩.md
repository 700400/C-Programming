# 리스트의 종류와 설명

#### 종류 & 설명

>1)단순 연결 리스트 : 구조체로 정의하며 포인터를 사용한다. malloc을 이용하여 노드를 생성한다.
>
>2)원형 연결 리스트 : 마지막 노드의 링크가 첫번째 노드를 가리키는 리스트이다.
>
>3)이중 연결 리스트 : 선형 노드를 찾기가 힘들고. 삽입이나 삭제시에 선행 노드가 필요하기 때문에 양방향으로 검색이 가능하다.

```
단순 연결 리스트예시

#include <stdio.h>
#include <stdlib.h>
typedef struct list
{
	int data;
	struct list* node;
}List;
List* number= NULL;
List* next= NULL;
int main(void)
{
  List* r = (List*)malloc(sizeof(List));
	r->data = 10;
	r->node = NULL;
	number = r;
	next = r;
 
	List* r1 = (List*)malloc(sizeof(List));
	next->node = r1;
	r1->data = 20;
	r1->node = NULL;
	next = r1;
	
	List* r2 = (List*)malloc(sizeof(List));
	next->node = r2;
	r2->data = 30;
	r2->node = NULL;
	next = r2;
	
	while(number)
	{
		printf("%d\n", number->data);
		number = number->node;
	}
}
```
# 트리의 종류 및 설명

#### 종류 & 설명

>1) Binary Tree : 이진 트리로 각 노드에 대해서 두개 이하의 자식을 가진다.
>
>2) Non - Binary Tree : 노드의 자식 개수에 대한 제한이 없다.
>

```
#include <stdlib.h>
typedef struct BinaryTree
{
	struct BinaryTree *l, *r;
    int data;
}B_T;
void print(B_T* p)// printf문을 제일 처음에 넣으면 전위 순회, 중간은 중위 순회, 끝은 후위 순회
{
	printf("%d\n", p->data);
	if(p->l) print(p->l);
	if(p->r) print(p->r);
}
B_T* mem()
{
	B_T* p=(B_T*)malloc(sizeof(B_T));
	p->l=p->r=NULL;
	return(p);
}
int main(void){
	B_T *r, *r1, *r2, *r3, *l1, *l2, *l3;
	l3= (B_T*)mem(); l3->data=11;
	l2= (B_T*)mem(); l2->data=9; 
    l1= (B_T*)mem(); l1->data=3; l1->r=l2; l1->l=l3;
    r3= (B_T*)mem(); r3->data=14;
    r2= (B_T*)mem(); r2->data=8; 
    r1= (B_T*)mem(); r1->data=7; r1->r=r2; r1->l=r3;
    r=  (B_T*)mem(); r->data=5;  r->l=l1;  r->r=r1;
    print(r);
}
```

